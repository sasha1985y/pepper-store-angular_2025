# Контекст
Компонент уже описан в ООП стиле

# Проблема
Каждый компонент не статичен. Он живой. И постоянно изменяет свое состояние

# Цикл жизни компонента
- Создание класса, который описывает DOM-компонент:
  - Регистрация данных (тип, данные, с которыми он работает, начальное состояние)
  - Рендеринг
  - Генерация DOM на основе шаблона (Virtual DOM, <template />, шаблонная строка, отдельный файл)
  - Вставка полученного DOM на страницу
  - Добавление обработчиков событий после рендеринга
  - ... (ререндеринг из-за изменения внутреннего состояния)
  - Уход из DOM дерева
  - Удаление вообще из памяти

# ...
# Изменение внутреннего состояния компонента по ходу его жизни (пока он еще отрисован)
- Когда мы создаем объект, который описывает UI-компонент, у него есть
  - внешние параметры (аналог props из React) — параметры с которыми инициализируется компонент
  - внутреннее состояние (аналог state из React) — значения, которые
    - инкапсулированы (хотя бы частично) внутри компонента
    - изменяются благодаря логике, которая содержится внутри компонента

Когда компонент зависит только от внешних данных, логика рендера линейна:
```
(props) => DOM
```

Когда у UI компонента появляется внутреннее состояние, появляется запрос на следующее поведение
```
(props + state) => DOM -[Events]-> state => DOM
```
- Изменение внутреннего состояния обновляет DOM
  - Тикание таймера
  - Приход данных по сети
- Изменение DOM обновляет внутреннее состояние
  - Пользовательский ввод

Единственная сложность в обеспечении этой взаимосвязи: эффективное обновление
- бесконечный цикл зависимости состояния от DOM
- точечные обновления
  - точечные обновления DOM-дерева
    - минимизация повторных отрисовок
    - сохранение контекстов
      - наличие обработчиков событий
      - сохранение внутреннего состояния

Задача эффективного обновления DOM очень сложна. Причем ее сложность вырастает кратно с увеличением DOM. Для решения этой задачи существуют инструменты, которые долго и эффективно развиваются
> Вывод: чем сложнее задача частичного обновления DOM тем сложнее шаблонизатор

- Шаблонизаторы становятся декларативными
  > Императивный стиль описывает "как сделать" (подробное описание каждого шага)
  > Декларативный стиль описывает желаемый результат, без уточнения механизма работы
- Шаблонизатор будет содержать некий "Язык программирования", который описывает инструкции
  - чтение данных => как при первом рендеринге, так и при повторных
  - условные операторы
  - циклы
  - обработчики событий => имеют привязку к состоянию с возможностью его изменить

```
[Component]        [Template]
  [Data]     ==>      [DOM]
  [Data]     <==      [DOM]
          two-way data
            binding
```
